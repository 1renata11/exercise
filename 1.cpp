#include <iostream>
#include <limits>

using namespace std;

// http://cppstudio.com/post/8299/
/*Задача на динамическое выделение памяти. Изначально есть указатель на массив с одним элементом.
Пользователь вводит число. Если оно больше 0 записываем его в массив. Далее пользователь вводит второе число, тут уже,
если оно больше 0, надо перевыделять память для 2-х элементов массива и записать в массив второе число.
И так далее…  для 3-х элементов, для 4-х…  пока пользователь не введет отрицательное число.*/

// всё, что делается единообразно и более одного раза - кандидат на вынос в функцию
int inputN(){
    int n;
    // выведем приглашение ко вводу
    cout << "Enter n: ";
    // внезапно, cin возвращает результат ввода и разбора данных. Если возвращается false - ввод и преобразование не удались. 
    // Потому - пытаемся ввести, пока у нас не получится
    while (! (cin >> n)){
        // уведомим пользователя, что он сделал не так
        cout << "Your entry must be a valid numeric value." << endl; 
        // сбрасываем флаг ошибки cin (чтобы будущие операции ввода-вывода работали правильно)
		cin.clear();
        // игнорируем весь ввода в количестве "максимальный размер ввода" до символа '\n', то есть перевод строки
		cin.ignore(numeric_limits<streamsize>::max(), '\n');
        // ещё раз выведем приглашение ко вводу
        cout << "Enter n: ";
    }

    return n;
}

void printArray(int* arr, int len){
    // в C/C++ массивы индексируются с 0 !!!!
    for (auto i = 0; i < len; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;    
}

int main()
{
    int s = 1, new_s, n;
    int *old_a = new int[s];

    n = inputN();
    if (n < 0) 
        cout << "Error!" << endl;
    
    // Собственно, приехали. Массивы в C/C++ индексируются с 0. Здесь и далее вся программа работает вопреки вам.
    // При обращении к простым массивам C/C++ выход за пределы массива проходит совершенно без реакции со стороны компилятора, этим язык отличается от pascal
    // Определили массив размера 1, обратились не s[0], а s[1] - пофиг, хоть s[1000], ваши проблемы, какие вы там данные хапнете, на какую левую переменную наедете.
    old_a[0] = n;
    
    printArray(old_a, s);
    
    // Сначала определили новый массив, переложили в него данные, потом пересоздали старый массив, снова переложили данные, снова удалили массив...
    // Совершенно неоптимально. Число операций выделения/освобождения памяти и перекладки данных следует минимизировать.
    // Эту оптимизацию предлагаю попробовать сделать самостоятельно.
    while(n >= 0)
    {
        n = inputN();
        if (n < 0) 
            break;
        
        new_s = s + 1;

        int *new_a = new int[new_s];
        // Кроме индексов, тут есть ещё одна ошибка:
        // вы обрабатываете в цикле два массива разного размера, но верхний предел цикла берётся по размеру бОльшего массива, что неверно.
        // Тут интересный эффект, когда две ошибки взаимоистребляются и позволяют программе работать корректно. Но оставлять так категорически нельзя.
        for (auto i = 0; i < s; i++)
        {
            new_a[i] = old_a[i];         
        }        
        new_a[s] = n;
        delete[] old_a;
        
        printArray(new_a, new_s);

        // тут ещё один залёт. Вы создаёте новую переменную с именем old_a, она никак не соотносится с переменной old_a, объявленной в голове программы. 
        // Следовательно, при заходе в цикл в new_a копируются данные из исходного массива old_a
        old_a = new int[new_s];
        for (auto i = 0; i < new_s; i++)
        {
            old_a[i] = new_a[i];
        }        
        delete[] new_a;
        s = new_s;
    }
    delete[] old_a;
    return 0;
}
