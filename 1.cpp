#include <iostream>
#include <limits>
#include <vector>

using namespace std;

// http://cppstudio.com/post/8299/
/*Задача на динамическое выделение памяти. Изначально есть указатель на массив с одним элементом.
Пользователь вводит число. Если оно больше 0 записываем его в массив. Далее пользователь вводит второе число, тут уже,
если оно больше 0, надо перевыделять память для 2-х элементов массива и записать в массив второе число.
И так далее…  для 3-х элементов, для 4-х…  пока пользователь не введет отрицательное число.*/

// всё, что делается единообразно и более одного раза - кандидат на вынос в функцию
int inputN(){
    int n;
    // выведем приглашение ко вводу
    cout << "Enter n: ";
    // внезапно, cin возвращает результат ввода и разбора данных. Если возвращается false - ввод и преобразование не удались. 
    // Потому - пытаемся ввести, пока у нас не получится
    while (! (cin >> n)){
        // уведомим пользователя, что он сделал не так
        cout << "Your entry must be a valid numeric value." << endl; 
        // сбрасываем флаг ошибки cin (чтобы будущие операции ввода-вывода работали правильно)
		cin.clear();
        // игнорируем весь ввода в количестве "максимальный размер ввода" до символа '\n', то есть перевод строки
		cin.ignore(numeric_limits<streamsize>::max(), '\n');
        // ещё раз выведем приглашение ко вводу
        cout << "Enter n: ";
    }

    return n;
}

void printArray (vector<int> a)
{
    for ( auto i = 0; i < a.size(); i++) {
        cout << a[i] << ' ';
      }
}

int main()
{
    int s = 1, n;
    vector<int> arr;
    n = inputN();
    if (n < 0) 
        cout << "Error!" << endl;
    
    // Собственно, приехали. Массивы в C/C++ индексируются с 0. Здесь и далее вся программа работает вопреки вам.
    // При обращении к простым массивам C/C++ выход за пределы массива проходит совершенно без реакции со стороны компилятора, этим язык отличается от pascal
    // Определили массив размера 1, обратились не s[0], а s[1] - пофиг, хоть s[1000], ваши проблемы, какие вы там данные хапнете, на какую левую переменную наедете.
    arr = {n};
    printArray(arr);
    
    
    // Сначала определили новый массив, переложили в него данные, потом пересоздали старый массив, снова переложили данные, снова удалили массив...
    // Совершенно неоптимально. Число операций выделения/освобождения памяти и перекладки данных следует минимизировать.
    // Эту оптимизацию предлагаю попробовать сделать самостоятельно.
    while(n >= 0)
    {
        n = inputN();
        if (n < 0) 
            break; 
        s = s + 1;
	arr.resize(s);
        arr[s-1] = n;
        // Кроме индексов, тут есть ещё одна ошибка:
        // вы обрабатываете в цикле два массива разного размера, но верхний предел цикла берётся по размеру бОльшего массива, что неверно.
        // Тут интересный эффект, когда две ошибки взаимоистребляются и позволяют программе работать корректно. Но оставлять так категорически нельзя.
         
         printArray(arr);

        // тут ещё один залёт. Вы создаёте новую переменную с именем old_a, она никак не соотносится с переменной old_a, объявленной в голове программы. 
        // Следовательно, при заходе в цикл в new_a копируются данные из исходного массива old_a
        
    }
   
    return 0;
}
